.. _security_considerations:

############
安全考虑因素
############

虽然构建按预期工作的软件通常很容易，但要检查没有人能够以 **非** 预期的方式使用它更加困难。

在Solidity中，这更为重要，因为你可以使用智能合约来处理令牌，或者甚至可能使用更有价值的东西。
此外，智能合约的每次执行都是在公共场合进行的，除此之外，源代码通常也是可用的。

当然，你总是要考虑有多大危险：
你可以将智能合约与对公众开放的Web服务进行比较（因此也可以与恶意行为者进行比较），
甚至可能是开放源代码。如果你只将购物清单存储在该网络服务上，则可能不必太在意，
但如果你使用该网络服务管理你的银行帐户，则应该更加小心。

本节将列出一些陷阱和一般安全建议，但可能，当然了，永远不完整。
另外，请记住，即使你的智能合约代码没有错误，编译器或平台本身也可能存在错误。 
可以在 :ref:`已知bug列表 <known_bugs>` 中找到编译器的一些公知的安全相关错误的列表,
这也是机器可读的。
请注意，有一个bug bounty程序，它涵盖了Solidity编译器的代码生成器。

与往常一样，使用开源文档，请帮助我们扩展此部分
（特别是，一些例子不会受到伤害）！

****
陷阱
****

私人信息和随机性
================

你在智能合约中使用的所有内容都是公开可见的，甚至是标记为 ``private`` 的局部变量和状态变量。

如果你不希望矿工能够作弊，在智能合约中使用随机数是非常棘手的。

重入
====

合约（A）与另一合约（B）之间的任何交互以及转移任何以太币移交控制权到该合约（B）。
这使得B可以在此交互完成之前回调到A。
举个例子，下面的代码包含一个bug（它只是一个片段，而不是一个完整的合约）：

::

    pragma solidity ^0.4.0;

    // 本合约包含一个BUG - 请勿使用
    contract Fund {
        /// 映射合约的以太坊份额。
        mapping(address => uint) shares;
        /// 撤回你的份额。
        function withdraw() public {
            if (msg.sender.send(shares[msg.sender]))
                shares[msg.sender] = 0;
        }
    }

这里的问题不是太严重，因为有限的gas是 ``send`` 的一部分，但它仍然暴露出一个弱点：
以太币转移总是包含代码执行，因此接收人可能是一个回调进入 ``withdraw`` 的合约。
这将让它获得多次退款并总体上取回合约中的所有以太币。
特别是，以下合约将允许攻击者多次退款，因为它使用 ``call`` 默认转发所有剩余的气体：

::

    pragma solidity ^0.4.0;

    // 本合约包含一个BUG - 请勿使用
    contract Fund {
        /// 映射合约的以太坊份额。
        mapping(address => uint) shares;
        /// 撤回你的份额。
        function withdraw() public {
            if (msg.sender.call.value(shares[msg.sender])())
                shares[msg.sender] = 0;
        }
    }

为避免重新入侵，你可以使用Checks-Effects-Interactions模式，如下所述：

::

    pragma solidity ^0.4.11;

    contract Fund {
        /// 映射合约的以太坊份额。
        mapping(address => uint) shares;
        /// 撤回你的份额。
        function withdraw() public {
            var share = shares[msg.sender];
            shares[msg.sender] = 0;
            msg.sender.transfer(share);
        }
    }

请注意，重新入侵不仅是以太传输的影响，而且是对另一个合约的任何函数调用的影响。
此外，你还必须考虑多合约情况。 被调用合约可以修改你依赖的另一个合约的状态。

Gas Limit 和 循环
=================

必须小心使用没有固定迭代次数的循环，例如，依赖于存储值的循环：
由于 gas limit 限制，交易只能消耗一定量的gas。无论是明确地还是仅仅由于正常操作，
循环中的迭代次数可以超过块 gas limit，这可能导致完整的合约在某一点停滞。
这可能不适用于仅用于从区块链读取数据的 ``view`` 函数。
尽管如此，这些功能可能会被其他合约作为链上操作的一部分进行调用，并使这些功能失效。
请在合约文件中明确说明此类情况。

发送和接收以太币
================

- 合约和 "外部账户" 目前都无法防止有人向他们发送以太。
  合约可以响应并拒绝常规转移，但仍有方法可以移动以太网而不需要创建调用。
  一种方法是简单地 "mine to" 合约地址，第二种方式是使用 ``selfdestruct(x)`` 。

- 如果合约收到以太币（没有调用函数），则执行回退功能。
  如果它没有回退功能，则将拒绝以太币（通过抛出异常）。
  在执行回退功能期间，合约只能依赖于当时可用的 "gas 津贴（gas stipend）"（2300燃气）。 这种津贴不足以以任何方式访问存储。
  为了确保你的合约能够以这种方式接收以太币，请检查回退功能的gas需求（例如，在Remix的 "details" 部分中）。

- 有一种方法，可以使用 ``addr.call.value(x)()`` 将更多gas转发给接收合约。
  这与 ``addr.transfer(x)`` 基本相同，区别是它转发所有剩余的gas并打开接收者执行更昂贵行为的
  能力（它只返回失败代码并且不会自动传播错误）。这可能包括回调发送合约或你可能没有想到的其他状态更改。
  因此，它为诚实用户提供了极大的灵活性，同时也为恶意行为者提供

- 如果你想使用 ``address.transfer`` 发送以太币，有一些细节需要注意：

  1. 如果接收者是合约，则会导致其执行回退功能，从而可以回调发送合约。
  2. 由于调用深度超过1024，发送以太币可能会失败。由于调用者完全控制调用深度，因此可以强制转移失败；
     考虑到这种可能性或使用 ``send`` 以确保始终检查其返回值。更好的（做法）是，使用收件人可以撤回以太币的模式编写你的合约来替换。 
  3. 发送以太币也可能失败，因为接收者合约的执行需要超过分配的gas（明确地使用 ``require`` ，
     ``assert`` ， ``revert`` ， ``throw`` 或者仅仅因为操作太贵了） - 它 "runs out of gas" （OOG）。
    如果使用带有返回值检查的 ``transfer`` 或 ``send`` ，这可能会为接收者提供阻塞发送合约进度的方法。
    同样，这里最好的做法是使用 :ref:`"withdraw"模式而不是"send"模式 <withdraw_pattern>` 。

调用栈深度
==========

外部函数调用可能会随时失败，因为它们超过1024的最大调用堆栈。在这种情况下，Solidity会抛出异常。
恶意操作者可能会在与你的合约交互之前强制调用堆栈达到较高值。

注意在这种情况下，如果调用堆栈耗尽 ``.send()`` **不会** 抛出异常，而是返回 ``false`` 。
低级函数 ``.call()`` ， ``.callcode()`` 和 ``.delegatecall()`` 的行为方式相同。

tx.origin
=========

切勿使用tx.origin进行授权。 假设你有像这样的钱包合约:

::

    pragma solidity ^0.4.11;

    //这个合约包含一个BUG - 请勿使用
    contract TxUserWallet {
        address owner;

        function TxUserWallet() public {
            owner = msg.sender;
        }

        function transferTo(address dest, uint amount) public {
            require(tx.origin == owner);
            dest.transfer(amount);
        }
    }

现在有人欺骗你把以太币发送到这个攻击钱包的地址：

::

    pragma solidity ^0.4.11;

    interface TxUserWallet {
        function transferTo(address dest, uint amount) public;
    }

    contract TxAttackWallet {
        address owner;

        function TxAttackWallet() public {
            owner = msg.sender;
        }

        function() public {
            TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
        }
    }

如果你的钱包已经检查了 ``msg.sender`` 进行授权，它将获得攻击钱包的地址，而不是所有者地址。
但是通过检查 ``tx.origin`` ，它获得了启动交易的原始地址，这仍然是所有者地址。 攻击钱包立即消耗所有资金。

次要的详情
==========
- 在 ``for(var i = 0; i <arrayName.length; i ++){...}`` 中， ``i`` 的类型将是 ``uint8`` ，因为这是最小的类型需要保持 ``0`` 值。
  如果数组的元素超过255个，则循环不会终止。
- 不占用整个32字节的类型可能包含 ``脏的高阶位`` 。
  如果你访问 ``msg.data`` ，这一点尤其重要 - 它会带来延展性风险：
  你可以定制交易，使用原始字节参数 ``0xff000001`` 和 ``0x00000001`` 来调用函数 ``f(uint8 x)`` 。
  两者都被输入到合约中，对于 ``x`` 而言，两者看起来都是数字 ``1`` ，但 ``msg.data`` 会有所不同，
  所以如果你使用 ``keccak256(msg.data)`` 对于任何事情，你会得到不同的结果。

****
建议
****

认真对待警告
============

如果编译器警告你某事，你应该更好地改变它。
即使你不认为此特定警告具有安全隐患，也可能存在其他问题。
我们发出的任何编译器警告都可以通过稍微更改代码来使之沉默。

另外通过添加 ``pragma experimental "v0.5.0";`` 来尝试尽早启用 "0.5.0" 安全功能。
请注意，在这种情况下， ``experimental`` 一词并不意味着安全功能在任何方面都有风险，
它只是一种方法，由于向后兼容性而启用一些尚未成为最新版Solidity功能的功能。

限制以太币的数量
================

限制可以存储在智能合约中的以太币（或其他令牌）的数量。
如果你的源代码，编译器或平台有错误，这些资金可能会丢失。
如果要限制损失，请限制以太币的数量。

保持小巧和模块化
================

保持你的合约规模小，且易于理解。在其他合约或库中单独列出不相关的功能。
关于源代码质量的一般建议当然适用：限制局部变量的数量，函数的长度等等。
文档化你的函数，以便其他人可以看到你的意图是什么，以及它是否与代码的不同。

使用Checks-Effects-Interactions模式
===================================

大多数函数将首先执行一些检查（谁调用函数，范围内的参数，是否发送足够的以太币，此人是否有令牌等）。
应首先进行这些检查。

第二步，如果所有检查都通过，则应对当前合约的状态变量产生影响。与其他合约的互动应该是任何职能的最后一步。

早期合约延迟了一些影响并等待外部函数调用以非错误状态返回。由于上面解释的重入问题，这通常是一个严重的错误。

另请注意，对已知合约的调用可能会导致调用未知合约，因此最好始终应用此模式。

包含故障安全模式
================

在使你的系统完全去中心化的同时将删除任何中间人，
它可能是一个好主意，特别是对于新代码，包括某种故障安全机制：

你可以在智能合约中添加一项功能，执行一些自我检查，例如 "有任何以太币泄漏吗？" ，"令牌的总和是否等于合约的余额？" 或类似的事情。
请记住，你不能使用过多的gas，因此可能需要通过离线计算提供帮助。

如果自检失败，合约会自动切换到某种"故障保护"模式，例如，禁用大多数功能，
将控制交给固定和可信任的第三方，或者只是将合约转换为简单的"把我的钱还给我"合约。

********
形式验证
********

使用形式验证，这可能去执行一个自动化数学证明，证明你的源代码符合某种格式规范。
规范仍然正式（就像源代码一样），但通常要简单得多。

请注意，形式验证本身只能帮助你了解你所做的事情（规范）与实现方式（实际实现）之间的区别。
你仍然需要检查规范是否符合你的要求，并且你没有错过它的任何意外影响。


