############
智能合约简介
############

.. _simple-smart-contract:

******************
一个简单的智能合约
******************

让我们从最基本的例子开始。 如果你现在不了解所有内容，这很好，我们稍后会详细介绍。

存储
====

::

    pragma solidity ^0.4.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public view returns (uint) {
            return storedData;
        }
    }

第一行简单地告诉（声明）源代码是（遵循）Solidity0.4.0版本（规范）写的，
或任何不破坏功能的更新版本（以上版本，但不包括版本0.5.0）。
这是为了确保合约不会突然与新的编译器版本表现不同。
关键字 ``pragma`` 以那种方式被调用是因为，通常来说，
pragmas是编译器有关如何处理源代码的指令
（例如 `pragma once <https://en.wikipedia.org/wiki/Pragma_once>`_ ）。

Solidity意义上的合约是代码（其*函数*）和数据（其*状态*）的集合，它位于以太坊区块链的特定地址。
``uint storedData;`` 行声明一个名为 ``storedData`` 的状态变量，类型为 ``uint`` （256位无符号整数）。
你可以将其视为数据库中的单个插槽，可以通过调用管理数据库的代码的函数来查询和更改它。
在以太坊的情况下，这种行为被合约拥有。 在这种情况下，函数 ``set`` 和 ``get`` 可用于修改或检索变量的值。

要访问状态变量，你不需要像在其他语言中那样使用 ``this.`` 前缀。

除了允许任何人保存一个可以被世界上任何人都可以访问的简单数字之外，
此合约并没有做太多事情（由于以太坊Ethereum建立的基础设施）。
而合约也没有一个（可行的）方法来阻止你发布此数字。 
当然，任何人都可以使用不同的值再次调用 ``set`` 并覆盖你的数字，
但你发布过的数字仍将保存在区块链的历史记录中。 
稍后，我们将看到你如何施加访问限制，以便只有你自己可以更改这个数字。


.. 提示::
    所有标识符（合约名称，函数名称和变量名称）都限制为ASCII字符集。
    可以将UTF-8编码数据保存在字符串变量中。
    

.. 警告::
    谨慎使用Unicode文本，因为类似的（甚至相同的）字符可以具有不同的代码点，
    因此将被编码为不同的字节数组。

.. index:: ! subcurrency

发行货币示例
============

下面的合约将实现最简单格式的加密货币。
它使凭空创造货币成为可能，但只有创建合约的人才能做到这一点（实施不同的发行方案是微不足道的）。
此外，任何人都可以向对方发送货币而无需使用用户名和密码进行注册 ——你只需要一个以太坊密钥对。


::

    pragma solidity >0.4.24;

    contract Coin {
        // 关键字“public”让这些变量可以从外部读取
        address public minter;
        mapping (address => uint) public balances;

        // 事件允许轻客户端有效地响应更改。
        event Sent(address from, address to, uint amount);

        // 这是构造函数，其代码仅在创建合约时运行
        constructor() public {
            minter = msg.sender;
        }

        function mint(address receiver, uint amount) public {
            if (msg.sender != minter) return;
            balances[receiver] += amount;
        }

        function send(address receiver, uint amount) public {
            if (balances[msg.sender] < amount) return;
            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            emit Sent(msg.sender, receiver, amount);
        }
    }

本合约介绍了一些新概念，让我们逐一介绍。

``address public minter;`` 行声明一个可公开访问的地址类型的状态变量。
``address`` 类型是一个不允许任何算术运算的160bit值。 它适用于保存属于外部人员的合约或密钥对的地址。
关键字 ``public`` 会自动生成一个函数，允许你从合约外部访问状态变量的当前值。
没有此关键字，其他合约无法访问该变量。 编译器生成的函数代码大致等同于以下::

    function minter() returns (address) { return minter; }

当然，添加一个完全相同的函数是行不通的，因为我们会有一个函数和一个具有相同名称的状态变量，
不过希望你能有这个概念——编译器会为你找出答案。

.. index:: mapping

下一行， ``mapping（address => uint）public balances;`` 也创建一个公有状态变量，
但它是一个更复杂的数据类型。 类型映射地址为无符号整数。
映射可以被视为 `哈希表 <https://en.wikipedia.org/wiki/Hash_table>`_ ，它们被虚拟地初始化，
使得每个可能的密钥都存在并被映射到字节表示全为零的值。 
但是，这种类比并不会太过分，因为既不可能获得映射的所有键列表，也不可能获得所有值的列表。
因此，要么记住（或者更好，保留列表或使用更高级的数据类型）你添加到映射中的内容，
或者在不需要这样的上下文中使用它，就像这样。 
在这种情况下， ``public`` 关键字创建的 :ref:`getter function <getter-functions>` 有点复杂。 
它大致如下所示::

    function balances(address _account) public view returns (uint) {
        return balances[_account];
    }

如你所见，你可以使用此功能轻松查询单个帐户的余额。

.. index:: event

``event Sent(address from, address to, uint amount);`` 行声明一个所谓的 "事件" ，
它在函数 ``send`` 的最后一行发出。 用户界面（当然还有服务器应用程序）可以在没有太多
花费的情况下监听区块链上发出的事件。 
一旦它被发出，监听器也将接收参数 ``from`` ， ``to`` 和 ``amount`` ，这使得跟踪交易变得容易。 
为了听取这个事件，你会使用::

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

注意如何从用户界面调用自动生成的函数 ``balances`` 

.. index:: coin

特殊函数 ``Coin`` 是在创建合约期间运行的构造函数，之后不能调用。它永久保存创建合约的人的地址：
``msg`` （与 ``tx`` 和 ``block`` 一起）是一个神奇的全局变量，它包含一些允许访问区块链的属性。
``msg.sender`` 始终是当前（外部）函数调用来自的地址。

最后，函数将实际上以合约结束，并且可以由用户和类似 ``mint`` 和 ``send`` 的合约函数调用，
如果 ``mint`` 函数被除了创建合约的帐户以外的任何人调用，则不会发生任何事情。
另一方面，任何人（已经有一些这些货币）都可以使用 ``send`` 来向其他人发送货币。
请注意，如果你使用此合约将货币发送到（任何）地址，当你在区块链浏览器中查看该地址时，你将看不到任何内容，
因为你发送货币和更改余额的事实仅保存在这个特殊的货币合约的数据存储区中。
通过使用事件相对容易去创建一个跟踪你的新货币的交易和余额的 "区块链浏览器" 。

.. _blockchain-basics:

**********
区块链基础
**********

对程序员来说，区块链作为一个概念并不难理解。 原因是大多数并发
（挖矿， `哈希 <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ ，
`椭圆曲线加密 <https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>`_ ，
`点对点网络 <https://en.wikipedia.org/wiki/Peer-to-peer>`_ 等）
都仅仅是提供一系列功能和约定。 
一旦你接受了给定的这些功能，你就不必担心底层技术 - 或者你必须知道Amazon的AWS如何在内部运行才能使用它吗？

.. index:: transaction

交易
====

区块链是一个全球共享的交易数据库。
这意味着每个人都可以通过参与网络来读取数据库中的条目。
如果要更改数据库中的某些内容，则必须创建一个所谓的必须被所有其他人接受的交易。
单词 transaction 意味着你要进行的更改（假设你想要同时更改两个值）要么根本没有完成，要么完全应用。
此外，当你的交易应用于数据库时，没有其他事务可以更改它。

举个例子，假设一个表格列出了电子货币中所有账户的余额。
如果请求从一个帐户转移到另一个帐户，则数据库的事务特性确保如果从一个帐户中减去该金额，则始终将其添加到另一个帐户。
如果由于某种原因，无法将金额添加到目标帐户，则也不会修改源帐户。

此外，交易总是由发送者（交易的创建者）以加密方式签名。
这使得可以直接保护对数据库的特定修改的访问。在电子货币的示例中，简单的检查确保只有持有账户密钥的人才能从中转账。

.. index:: ! block

区块
====
要克服的一个主要障碍是，用比特币的方式称为 "双花攻击" ：
如果网络中存在两个想要清空账户的交易，即所谓的冲突，会发生什么？

对此的抽象答案是你不必关心的。交易的顺序将为你选好，并且事务将捆绑到所谓的 "块" 中，
然后它们将在所有参与节点之间执行和转发。
如果两个交易相互矛盾，那么最终成为第二个的交易将被拒绝并且不会成为该块的一部分。

这些块在时间上形成线性序列，这是“区块链”一词的起源。
块以相当规则的间隔添加到链中 - 对于以太坊，这大约每17秒一个块。

作为 "订单选择机制" （通常被称为 "挖矿" ）的一部分，可能会发生块不时被回滚，但仅在链的 "末端" 发生。
顶部添加的块越多，这种可能性越低。因此，你的交易可能会被回滚甚至从区块链中删除，但等待的时间越长，它的可能性就越小。

.. 注意::
    交易不保证在下一个区块或任何未来的特定区块上发生，因为矿工需要包括交易而不是交易的提交者。
    这适用于函数调用和合约创建事务。
    
    如果你想安排你的合约未来的调用，可以使用 `闹钟 <http://www.ethereum-alarm-clock.com/>`_ 服务。

.. _the-ethereum-virtual-machine:

.. index:: !evm, ! ethereum virtual machine

************
以太坊虚拟机
************

概述
====

以太坊虚拟机或EVM是以太坊中智能合约的运行时环境。
它不仅是沙箱，而且实际上是完全隔离的，这意味着在EVM内部运行的代码无法访问网络，文件系统或其他进程。
智能合约甚至可以限制其他智能合约的使用。

.. index:: ! account, address, storage, balance

账户
========

在以太坊中有两种帐户共享相同的地址空间：由公钥-私钥对（即人类）控制的 **外部帐户** 以及由与
账户一起存储的代码控制的 **合约帐户** 。

外部帐户的地址是根据公钥确定的，而合约的地址是在创建合约时确定的（它来自创建者地址和从该地址
发送的交易序号，即所谓的 "随机数" ）。

无论帐户是否存储代码，EVM都会平等对待这两种类型。

每个帐户都有一个持久的键-值存储区，映射256bit单词到称为 **存储** 的256位单词。

此外，每个帐户在以太网中都有 **余额** （准确地说是 "Wei" ），可以通过发送包含以太币的交易进行修改。


.. index:: ! transaction

交易
============

交易是从一个帐户发送到另一个帐户的消息（可能是相同的或特殊的零帐户，见下文）。
它可以包括二进制数据（其有效载荷）和以太网。

如果目标帐户包含代码，则执行该代码，有效负载被提供作为输入数据。

如果目标帐户是零帐户（地址为 "0" 的帐户），则该交易将创建 **新合约** 。
如前所述，该合约的地址不是零地址，而是从发送方及其发送的交易序号（ "nonce" ）得出的地址。 
这种合约创建交易的有效载荷被认为是EVM字节码并被执行。 此执行的输出将永久存储为合约代码。
这意味着，为了创建合约，你不会发送合约的实际代码，而是EVM字节码被执行时返回的实际代码。

.. note::
  当合约正在被创建时，其代码仍为空。
  因此，在构造函数执行完毕之前，不应回调构造中的合约。

.. index:: ! gas, ! gas price

Gas
===
一旦交易创建，每笔都收取一定数量的 **gas** ，
其目的是限制执行交易和支付执行所需的工作量。当EVM执行交易时，根据特定规则逐渐耗尽gas。

**gas price** 是交易创建者设定的值，他必须从发送账户预先支付 ``gas_price * gas`` 。
如果在执行后剩下一些gas，它将以相同的方式退还。

如果gas在任何点用完（即它是负的），则触发gas不足异常，这将恢复对当前调用框架中针对状态所做的所有修改。

.. index:: ! storage, ! memory, ! stack

Storage, Memory 和 Stack
=============================

以太坊虚拟机有三个可以存储数据的区域。

每个帐户都有一个名为 **storage** 的数据区，它在函数调用之间是持久的。
storage是一个键-值存储，可将256bit单词映射到256bit单词。
不可能从合约中枚举storage，并且读取成本相对较高，甚至更难以修改storage。
合约既不能读取也不能写入任何storage，除了它自己的。

第二个数据区称为 **memory** ，其中一个合约为每个消息调用获得一个新清除的实例。
memory是线性的，可以在字节级寻址，但读取限制为256位宽度，而写操作可以是8位或256位宽度。
当访问（无论读取还是写入）先前从未访问过的memory单词（即，单词内部的任何偏移）时，memory按字（256位宽度的）扩展。
扩展时，必须支付gas费用。 随着memory的增大，gas花费越高（它以二次方级数缩放）。

EVM不是寄存器机器而是堆栈机器，因此所有计算都在被称做 **stack** 的数据区域上执行。 
它的最大大小为1024个元素，包含256bit位的单词。 
通过下面的方式（可以）访问仅限于顶端（top end）的堆栈区：
可以将最顶部的16个元素之一复制到堆栈的顶部，或者将最顶端的元素与其下面的16个元素之一交换。
所有其他操作从堆栈中取最顶部的两个（或一个或多个，取决于操作）元素并将结果推送到堆栈。
当然可以将堆栈元素移动到存储或内存，但是如果不首先移除堆栈的顶部，就不可能只访问堆栈中更深的任意元素。

.. index:: ! instruction

指令集
======

EVM的指令集保持尽量小，以避免可能导致共识问题的错误执行。
所有指令都基于256位单词的基本数据类型。
存在常用的四则运算，位运算，逻辑运算和比较操作。
有条件和无条件跳转是可能的。 
此外，合约可以访问当前块的相关属性，如其编号和时间戳。

.. index:: ! message call, function;call

消息调用
========

合约可以通过消息调用方式调用其他合约或将以太币发送到非合约帐户。
消息调用类似于交易，因为它们具有源，目标，数据有效负载，以太币，gas和返回数据。
实际上，每个交易都包含一个顶级消息调用，而这反过来又可以创建进一步的消息调用。

合约可以决定通过内部消息调用，它的剩余 **gas** 应该被发送多少，以及它想保留多少。
如果内部调用中发生了out-of-gas异常（或任何其他异常），则将通过放入栈顶的错误值来发出信号。
在这种情况下，只有与该内部消息调用一起发送的gas会被消耗掉。
在Solidity中，正在调用的合约在这种情况下默认会导致手工的异常，以便异常会 "冒泡" 调用堆栈。


如前所述，被调用的合约（可以与调用者相同）将接收新清除的内存实例，
可以访问在一个名为 **calldata** 的单独区域中被提供的调用有效负载。
合约完成执行后，它可以返回数据，这些数据将存储在调用者预先分配的调用者内存中的某个位置。

调用深度被 **限制** 为1024，这意味着对于更复杂的操作，循环应优先于递归调用。

.. index:: delegatecall, callcode, library

委托调用 / 调用代码和库
====================================

存在一个消息调用的特殊变体，名为 **delegatecall** ，它与消息调用相同，除了目标地址的代码在被调用合约上下文中执行是个事实之外。
而且 ``msg.sender`` 和``msg.value``不会改变它们的值。

这意味着合约可以在运行时从不同的地址动态加载代码。
Storage，当前地址和余额仍然指向被调用合约，只有代码来自被调用地址。

这使得在Solidity中实现 "库" 功能成为可能：
可重复使用的库代码，可应用在合约的存储上，例如，为了实现复杂的数据结构。

.. index:: log

日志
====

可以将数据存储在特殊索引的数据结构中，该数据结构一直映射到块级别。 
这个名为 **日志** 的功能由Solidity使用，以实现 **事件** 。
合约在创建后无法访问日志数据，但可以从区块链外部有效地访问它们。 
由于日志数据的某些部分保存在 `bloom filters <https://en.wikipedia.org/wiki/Bloom_filter>`_ 中，
因此可以以高效且加密的方式搜索此数据，因此网络对等体不下载整个区块链（“轻客户”）仍然可以找到这些日志。

.. index:: contract creation

Create 调用
===========

合约甚至可以使用特殊操作码创建其他合约（即，它们不会简单地调用零地址）。 
这些 **create 调用** 和普通消息调用之间的唯一区别是有效负载数据（是否）被执行，
（执行）结果作为代码被保存，调用者/创建者接收堆栈上新合约的地址。

.. index:: selfdestruct, self-destruct, deactivate

停用和自毁
============================

从区块链中删除代码的唯一方法是在该地址的合约执行 ``selfdestruct`` 操作。
存储在该地址的剩余以太坊代币将发送到指定目标，然后存储和代码从state中被删除。
理论上删除合约听起来是个好主意，但它有潜在的危险，比方说有人发送以太坊代币来删除合约，然后代币永远丢失了。

.. 警告::
    即使合约的代码不包含对 “selfdestruct” 的调用，它仍然可以使用 ``delegatecall`` 或 ``callcode`` 来执行该操作。

.. 提示::
    旧合约的删减可能会，也可能不会被以太坊的客户端程序执行。另外，归档节点可选择无限期保留合约存储和代码。

.. 提示::
    目前， **外部账户** 不能从状态中移除。


